<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <title>Test Task</title>
</head>
<body>
<div class="container">
    <h1>Верстка та Загальне</h1>
    <ol>
        <li>
            <p>
                1. Важливо зауважити, що before та after - це псевдоелементи, що створюються за допомогою CSS, тому їх значення не можна змінити безпосередньо в JavaScript, але е  можливість змінювати значення before та after в CSS за допомогою JavaScript.
                Щоб змінити значення before та after з CSS, потрібно спочатку отримати доступ до стилю елемента з допомогою JavaScript. Можна зробити це за допомогою властивості style об'єкта елемента.
                
            </p>
        </li>
        <li>
            <p>
                2. 1em - це одиниця виміру, що вказує на відстань від поточного шрифту до іншого елемента в залежності від його розміру. Значення "1em" завжди відноситься до розміру шрифту, встановленого для батьківського елемента. Наприклад, якщо ми встановимо розмір шрифту для батьківського елемента в 16 пікселів, то "1em" буде еквівалентним 16 пікселям.
            </p>
        </li>
        <li>
            <p>
                3. Е три способи реалізаціі , перший це "inline-block", другий - "grid", і третій - "flex-box"
            </p>
            <div class="container-1">
                <div class="box-1"></div>
                <div class="box-1"></div>
                <div class="box-1"></div>
            </div>
            <div class="container-2">
                <div class="box-2"></div>
                <div class="box-2"></div>
                <div class="box-2"></div>
            </div>
            <div class="container-3">
                <div class="box-3"></div>
                <div class="box-3"></div>
                <div class="box-3"></div>
            </div>
        </li>
        <li>
            <p>
                4.Для сортування масиву об'єктів за датами можна використати метод sort() та функцію порівняння.

                У функції порівняння ми можемо отримати значення дати кожного об'єкта за допомогою "new Date() та порівняти їх.
            </p>
            <pre class="code">
          array.sort((a, b) => {
            const dateA = new Date(a.date);
            const dateB = new Date(b.date);
            return dateA - dateB;
          });
        </pre>
        </li>
        <li>
            <p>
                5. Щоб вивести id натиснутого div всередині root у консоль, можна використати подію click та метод addEventListener().
                Таким чином коли будь-який елемент div всередині елемента з id "root" буде натиснутий, відбудеться виклик функції-обробника події, яка визначить, що це саме елемент div, і виведе його id у консоль.
            </p>
            <pre class="code">
                const root = document.getElementById('root');

                root.addEventListener('click', (event) => {
                  const target = event.target;
                  if (target.tagName === 'DIV') {
                    console.log(target.id);
                  }
                });
        </pre>
        </li>
    </ol>
    <h1>Angular</h1>
    <ol>
        <li>
            <p>
                1.кщо коротко, то *ngIf це структурна директива котра додає або видаляє елемент з DOM в залежності від завданоІ умови, тоді як [hidden] приховує або показує елемент з допомогою CSS
            </p>
        </li>
        <li>
            <p>
                2.  Observable - це клас в Angular, який використовується для підписки на дані та взаємодії з ними. Він представляє асинхронний потік даних, який може містити нуль, один або більше значень. Observable забезпечує можливість асинхронного отримання даних та реагування на їх зміни..
            </p>
        </li>
        <li>
            <p>
                3. Правильними відповідями є 1 2 та 3 оскільки немає жодного компонента з тегом "hello" і відповідно не можна інтерполювати "name ".
            </p>
        </li>
        <li>
            <p>
                4. Правильними відповідями є 2, 3, і 4. В першому кейсі не використовуємо Output, а в п'ятому назва компонента має бути написана з малих літер та включена в шаблон за допомогою тега "animal-noise".
            </p>
        </li>
        <li>
            <p>
                5. Правильними відповідями є 2, 3, і 4 так як властивості MovingObject не є резервними, але необхідні для успадкування і реалізації методів класів Positionable і Rotatable.
            </p>
        </li>
        <li>
            <p>
                6. Правильними відповідями є вердження 1 2 та 3 тому що клас Positionable не можна змінити на інтерфейс без помилок компілятора, оскільки в класі визначені не лише властивості, але й їх значення за замовчуванням. А властивості MovingObject є необхідними для коректної реалізації класу.
            </p>
        </li>
        <li>
            <p>7.</p>
            <pre class="code">
          &lt;ul>
            &lt;li *ngFor="let address of addresses">
              &lt;app-address [address]="address"></app-address>
              &lt;/li>
          &lt;/ul>
        </pre>
        </li>
    </ol>
    <h1>Node JS</h1>
    <ol>
        <li>
            <p>
                1. Package.json – це конфігураційний файл, що задає інформацію про поточний пакет – ім’я, версія, автор, вказує список залежностей (які сторонні пакети потрібні для його роботи). 
                Тож, дозволяє повністю налаштувати пакет. Файл обов’язково має розміщуватись у кореневій папці проекту. 
                Крім того, "package.json" може містити скрипти, які виконуються за допомогою npm, такі як запуск сервера або збірка проекту. Це дозволяє легко автоматизувати різні процеси в проекті.

            </p>
        </li>
        <li>
            <p> GET: використовується для отримання інформації з сервера. Коли клієнт надсилає запит GET на сервер, сервер відповідає запитуваною інформацією.</p>
            <p> POST: використовується для надсилання даних на сервер. Коли клієнт надсилає запит POST на сервер, сервер зберігає дані та відповідає підтвердженням.</p>
               <p>PUT: використовується для оновлення існуючого ресурсу на сервері. Коли клієнт надсилає запит PUT на сервер, сервер оновлює ресурс і відповідає підтвердженням.</p>
               <p>DELETE: використовується для видалення ресурсу з сервера. Коли клієнт надсилає серверу запит DELETE, сервер видаляє ресурс і відповідає підтвердженням.</p>
               <p>HEAD: подібно до запиту GET, але сервер повертає лише заголовки HTTP, а не вміст ресурсу.</p>
               <p>OPTIONS: використовується для отримання підтримуваних методів HTTP та іншої інформації про ресурс.</p>
        </li>
        <li>
            <p>
                3. Локальне встановлення пакета означає, що він буде доступний тільки для конкретної директорії проекту, в якій він встановлений. Крім того, локально встановлений пакет зазвичай залежить від інших пакетів, які також встановлені локально в цій же директорії. 
                Це дозволяє проектам мати свої власні залежності, незалежні від інших проектів.
                Глобальне встановлення пакета означає, що він буде доступний для всіх проектів на тому ж сервері або в системі. 
                Глобально встановлені пакети зазвичай мають більш широке призначення, такі як інструменти розробки, які можуть використовуватись в будь-якому проекті..
            </p>
        </li>
        <li>
            <p>
                4. Спочатку ми імпортуємо EventEmitter з пакету events, створюємо новий екземпляр eventEmitter і встановлюємо два обробники подій на подію "myEvent".
                Виконується console.log зі строкою "Statement A".
                Ми викликаємо подію "myEvent" за допомогою методу emit. Обидва обробники подій повинні виконатися в порядку, в якому вони були встановлені, тому обробники "FIRST" і "SECOND" повинні бути виконані в цьому порядку.
                Спочатку виконується обробник "FIRST", який виводить "Emitted Statement - FIRST" в консоль.
                Потім виконується другий обробник "SECOND", який виводить "Emitted Statement - SECOND" в консоль.
                Виконується console.log зі строкою "Statement B".
                Тому в консоль буде виведен такий код:
            </p>
            <pre class="code">
            Statement A
            Emitted Statement - FIRST
            Emitted Statement - SECOND
            Statement B
          </pre>
        </li>
        <li>
            5. Проблема з використанням async/await в цьому прикладі полягає в тому, що цикл forEach не очікує на виконання async функцій, тому функція може завершитися до того, як виконання всіх async функцій буде завершено, що може призвести до непередбачуваних результатів.
            Щоб вирішити цю проблему, можна замість циклу forEach використовувати цикл for...of, який очікує на виконання async функцій. Також можна використати метод Promise.all, який дозволяє чекати на виконання всіх async функцій, що повертають проміси.import fs from 'fs-promise'
            <pre class="code">
                async function printFiles () {
                    const files = await getFilePaths() // Assume this works fine
                  
                    for (const file of files) {
                      const contents = await fs.readFile(file, 'utf8')
                      console.log(contents)
                    }
                  
                    або
                  
                    await Promise.all(files.map(async (file) => {
                      const contents = await fs.readFile(file, 'utf8')
                      console.log(contents)
                    }))
                  }
              </pre>
        </li>
        <li>
            <p>
                6. module.exports у Node.js використовується для експортування змінних, функцій та об'єктів з модулю, щоб їх можна було використовувати в інших модулях.
            </p>
            <pre class="code">
             greeting.js
            module.exports = "Hello World!";

             index.js
            const greeting = require("./greeting");

            console.log(greeting);            
        </pre>
        <p>При виконанні цього кода ми побачимо у консолі "Hello World!"</p>
        </li>
    </ol>
    <h1>Wordpress</h1>
    <ol>
        <li>
            <p>
                1. У WordPress домашня сторінка може мати декілька назв, включаючи "front page", "home page", "landing page" тощо. Якщо тема має спеціально визначений шаблон для відображення домашньої сторінки, WordPress автоматично використовує його при відображенні сторінки. Назва файлу шаблону може варіюватись в залежності від версії WordPress та налаштувань теми.

                Отже, варіанти 1, 2, 3 і 4 можуть використовуватись для відображення домашньої сторінки, якщо вони мають спеціальні шаблони для цієї сторінки і вони активовані в темі.
            </p>
        </li>
        <li>
            <p>
                2. Правильнимим відповідями є 3 і 4.
            </p>
        </li>
    </ol>
</div>
</body>
</html>
